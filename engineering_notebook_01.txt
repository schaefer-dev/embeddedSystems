-------------------------- Engineering Notebook 01 --------------------------
---------------------------- Week 20.04 - 30.04 -----------------------------
-----------------------------------------------------------------------------
--------------- Rafael Dewes, Kevin Mueller, Daniel Schaefer ----------------
-----------------------------------------------------------------------------

# Sat. 21.04
- Daniel: Reading + Studying of 3pi user Manual + marking important parts + reading some corresponding parts of Data sheet + online resources from "hackaday" regarding usage of 3pi robot
	https://youtu.be/Xh5R6Pnk6gA
	https://youtu.be/QYQE_za8KQQ
	https://youtu.be/E2GtvigNPX8
	https://youtu.be/9XjSJV5MPc0
	https://youtu.be/tIL-2lZAFZo

- Rafael: Familiarising with resources on robots

# Sun. 22.04
- Daniel: Reading + Studying of zumo user Manual + marking important parts + reading some corresponding of Data sheet
- Kevin: Learning Matlab and Simulink, common workflows, project setup and version controll

# Mon. 23.04
- Daniel: both clion and manual flash fails with following error.
    Manual flashing using:
    "avrdude -p m32u4 -c avrispv2 -P /dev/tty.usbmodem00110791 -U flash:w:collector.hex"
        avrdude: stk500v2_command(): command failed
        avrdude: initialization failed, rc=-1
                Double check connections and try again, or use -F to override
                this check.

    -> Turns out it was on on/off switch.
    Environment now working perfectly in both commandline and clion

    Group Meeting + Discussion:
    Kevin takes care of Hybrid Automata
    Daniel and Rafael PINs and Interrupts

    Relevant Ressources are being collected in GitHub wiki

- Daniel: Researching SPI, Master-Slave relation and the necessary pins + how data is being transfered (clock timing)
- Kevin: Studied fundamental microcontroller concepts (blogs, videos, wikipedia).
- Rafael: Read through communication module documentation; looked for external resources regarding pins, communication protocols

# Tue. 24.04
- Kevin:
    Re-built bouncing ball and problem A4 a) in Simulink to better understand the concepts.
    Studied Simulink's "Getting Started" tutorials (charts, actions, hierarchies, parallelism, events) as well as several video tutorials and explored sf_aircontrol and sf_security.
    Started working on Milestone 1 task "Hybrid Automata".
- Rafael: Read https://www.embeddedrelated.com/showarticle/453.php , watched https://youtu.be/iqMiI9Zgxhk

- Daniel: SPI Videos: 	https://youtu.be/iqMiI9Zgxhk
						https://youtu.be/9XjSJV5MPc0
		  RS232 Lecture: https://youtu.be/BOS1s-EqjCI
		  I2C Lecture: https://youtu.be/OGRH-6cz8Z8
		  Reading "Introduction to Microcontrollers" Chapter 1-9 starting with https://www.embeddedrelated.com/showarticle/453.php


# Wed. 25.04
- Kevin: Modelled Milestone 1 Hybrid Automata in Stateflow. Differential drive motor signals still missing.
    Modelled separate differential drive motor.
- Rafael: Read up on Interrupts, started linking interrupts and pins

# Thu. 26.04
- Kevin: Modelled Milestone 1 Hybrid Automata in Stateflow.
- Rafael: Milestone 1 interrupts

# Fri. 27.04
- Daniel: New understanding of Task1. It does not refer to the entire atmega328, but instead we should only work with the schematic, preceding the cheatsheet.
    This task seems much more realistic without pasting 300pages datasheets.
    Reading in Datasheet of RF module and ADC
    + Kevin showed results of Hybrid Automata in Stateflow, discussion of work that is still TODO

# Sat. 28.04
- Rafael: Reviewed tasks for Milestone 1 and redid answers with regard to interrupts
- Daniel: Completed Reading Wireless chip datasheet + improved PIN Descriptions and use cases for all pins contained on cheatsheet. Only remaining problem is communication with the ADC. If this happens over SPI the pins "system clock"  and "I/O" Clock should be swapped on the ADC.
   Also finished all mentioned PINs for Collector
- Kevin: Modelled Hybrid Automata based on Stateflow model and description text.

# Sun. 29.04
- Daniel: Extended chapter of PINs which have to be driven at the same time.
	Extended chapter of PINs which must not be driven at the same time.
	Also included specific usecase explanations for all PINs listed on the cheatsheet now.
- Rafael:



	-------------------------- Engineering Notebook 02 --------------------------
	---------------------------- Week 03.05 - 14.05 -----------------------------
	-----------------------------------------------------------------------------
	--------------- Rafael Dewes, Kevin Mueller, Daniel Schaefer ----------------
	-----------------------------------------------------------------------------

# Sat. 06.05
- Daniel: Studying of Simulink Documentation and Tutorials on YouTube

# Sun. 06.05
- Daniel: Experimenting with simulink, especially related to plotting of roboter positions simultaniously into a single "map plot"

# Mon. 07.05
- Group Meeting Discussion of Layout
				Scout:
				- (DONE) max speed laut datenblatt fuer motor
				- initial position
				- 4 photo sensoren + noise (value domain rausfinden)
				- Minimalstrategie implementieren

				Collector:
				- (DONE) max speed laut datenblatt fuer motor
				- initial position
				- 3 Proximity sensoren + noise (value domain rausfinden)
				- Minimalstrategie implementieren
				- gegner pushen, scount ignorieren wenn am pushen
				- darf nicht team mate out of bounds pushen

				Referee:
				- communication bit/byte-wise, message size, ack, timing laut RF
				- 5% chance of losing message (every comminunication)
				- Bounding box und ouf bounds check
				- berechnet punktestand (jede sekunde kuken wer im licht (vom God) ist und drauf addieren)
				- gibt aktuelle position und winkel an jeden roboter alle x zeitintervalle

				God:
				- Licht (pattern und random)
				- Generates sensor readings basiernd auf den realen position (inkl noise) der anderen spieler
				- Addiert noise auf sensorsignals und sendet es zu den robotern
				- drift/noise für jeden spieler (bekommt motor signale von den
				Roboter, addiert noise und berechnet mit eigenem Diff drive die wirkliche
				Position)
				- Gibt wirkliche position zu jedem Zeitpunkt zum Referee weiter
				- managet Kollisionen

				Colliosion zunächst nur vereinfacht durch einfaches wegschieben der
				Gegner modellieren.

				Workload for team members:
				Step 1: Bis Dienstag 08.05
				Daniel: RF Modul ansehen, Motor input value range, sensor value domain (photo, proximity)
				Rafi: Konzept Schnittstellen
				Kev: Diff drive und roboter als datei/modul, tcp communication

- Daniel: Reading of RF Module Datasheet with focus on data-transfer between Scout and Collector. Notes regarding implementation of Auto-Ack + Bidirectional communication and package/payload content.
		Reading of Datasheet Scout/Collector to gain detailed information on value domains of proximity and photosensors and the power delivery to motors on each robot.
- Kevin: Created very basic reference model for collector, implement TCP communication from Simulink to Unity

# Tue. 08.05
- Group Meeting:
			Step 2: Bis Mittwoch 09.05
			Daniel: Roboter, random fahren und off switch wenn God sagt stehen bleiben. Robots.
			Rafi: Punkstand berechnen. Referee.
			Kev: Visualisierung fertig machen. Licht. God.

- Daniel: Implementation of Opponent tactic including the generation of random coordinates to which the robot automatically turns and drives, upon arrival new random coordinates are generated. Fixed Zero-Line-Crossing with condition modifications of allowing small differences between desired and actual theta values (angle towards "goal").
- Kevin: Finished implementation of visualization in Unity for every data we have + Interface from simulink in God model. Integrated collector model created by Daniel into root model as referenced model. Fixed errors related to algebraic loops.

# Wed. 09.05
- Group Meeting:
			Step 3: Bis Donnerstag 10.05
				- Collector dreht sich manchmal um die falsche seite (also z.B. 300 grad rechts rum statt 60 grad links rum)
					Und in seltenen Fällen dreht er sich ewig nach links und rechts und links und rechts etc etc.
			Daniel:	- Eigener Collector random fahren und wenn harvest position kommt dahin fahren. Collector A.
					Existierendes Opponent modell erweitern durch die Funktionalität zu der Harvest position zu fahren
					(Position als Input). Modell dann 2 mal referenzieren, beim eigenen Collector sendet der Scout die
					position an diesen Input und beim Gegner bleibt der input einfach leer. Dadurch brauchen wir nur
					ein referenced model für beide Collectoren.
					Wenn man in model.slx auf opponent klickt dann öffnet er das referenz modell und egal auf welches man
					klickt werden darin die daten von nur einer der beiden Instanzen der letzten Simulation angezeigt.
					Die Daten welcher Instanz angezeigt werden kann man ändern in Visibility Options.
					In the Simulink Editor, select the Diagram > Subsystem & Model Reference > Model Block Normal Mode Visibility
					https://de.mathworks.com/help/simulink/ug/simulate-models-with-multiple-referenced-model-instances-1.html#bvaxabx
			Rafi:	- Punkstand berechnen. Referee.
				- Referee Kommunikation. Referee.
				- Out of bounds check. Referee.
			Kev: 	- Gegner Scouts implementieren. Scout B.
				- Licht. Gott aufräumen. God.
				- Unity als exe und hochladen.

- Daniel: Opponent Model can now receive coordinates, which ALWAYS overwrite the current destination (which causes the robot to turn and drive towards that coordinate). This will be used for our collector, which receives these coordinates from the scout.
	 		Additionally the opponent model now implements a "OFF_CONDITION" which is used to turn of the motor entirely (to e.g. stand still for 60s when pushed out of bounds or to demonstrate the pushing process of an opponent). The robot motor will be turned off as long as the input value is >0.
- Kevin: Refinements and release of the visualization. Implemented the light to move randomly. Created referenced models for scouts and other general structural improvements with reference models and subsystems.

# Thu. 10.05
- Daniel: Reworking of turning cases for all robots, avoiding divergence in unfortunate rounding cases close to -179 and 180 degrees. Fixed rotation locks for both scout and collector
And significantly improved performance in calculation of turning to next destination including perfect rotation selection, which significantly improves roboter throughput and utilization
		1  -  -1 = 2   > turn right
		90 - -10 = 100 > turn right
		90 - -90 = 180 > turn right
		90 - -110 = 200 > turn left
		180 - -179 = 360 > turn left

		-90 - 1  = -1 > turn left
		-1 - 90  = -91 > turn left
		-160 - 20 = -180 > turn left

		-360 < x < -180 -> right
		-180 < x <  0   -> left
		 0   < x <  180 -> right
		 180 < x <  360 -> left
	Implemented motor specifications (max speed) into differential drive using existing wheel and roboter parameters
Kevin: Added random noise to wheel velocities and calculation of real position in God model

Daniel: Summary of stuff that is still TODO:
	 Rafael: Hitbox implementation,
	         Opponent roboters which get touched by another roboter get signaled a 1 into the off_condition until simulation is finished
	         Roboter out of bounds, gets signaled a "1" into the off_condition for 60seconds
	         Generation of Proximity sensor data (lasors at the front, left and right) readings from 0-255. Implemented by shooting a ray out of roboter position in angle theta, theta+90, theta-90 and checking if they hit another roboters hitbox or not in range 30cm or less (+noise on that sensor data)
		 		 	 Points awarded to each team according to Collector position and specified calculation

	IMPORTANT: How messages are encoded does not matter, we can just use seperate lanes for X,Y,Theta and send the coordinates directly.

	 Kevin: Sensor data for different photosensors (+noise)
	 Kevin: Scout reads photosensor data and sends good coordinates to collector
	 Kevin: Scout sends its position (not theta) to collector every 0.1s

	 Daniel: Referee sends position updates to robots every 10 seconds
	 Daniel: Robots handle position update sent by referee every 10 seconds
	 Daniel: Collector receives good coordinates from scout and drives there immediately
	 Daniel: Collector receives and holds scout position
	 Daniel: Collector tries to push opponent whenever proximity sensors indicate the existance of an opponent, make sure to not drive out of bounds yourself
	 Daniel: Collector is NOT ALLOWED to push own scout out of bounds


	 WHOEVER IS FINISHED FIRST: actual pushing of robots if they touch the front of a driving robot


	 Improvements after core is done:
	 - Improved collision handling + Rotating bounding boxes

	 Least important improvements:
	 - If sensing with proximity sensors at the sides turn towards if the sensed robot is opponent and push out of bounds
	 - Intelligent turning of scout depending on difference in photosensor readings (brighter on the right -> turn right until front is brightest spot)

	 New information:
	 - Bounding boxes should rotate with Robots
	 - Collisions should "look right"

# Fri. 11.05
- Daniel:
  Implemented: Robots handle position update sent by referee every 10 seconds
  Implemented: Collector receives good coordinates from scout and drives there immediately
  Implemented: Collector tries to push opponent whenever proximity sensors indicate the eixtance of an opponent
  TODO: check for scout when pushing, check for out of bounds

# Sat. 12.05
- Daniel:
  Implemented: photo sensor readings are now build continiously (algebraic loop)
  Implemented: Referee sends position updates received from god every t seconds to our robots
  Fix: updates between referee and robots are now working without causing an unsolvable algebraic loop
  Fix: Points for both teams are beeing counted again correctly depending on collector/light position
  Fix: Fixed integral reset case for referee update, which caused problems whenever values in the update were negative (expecially theta), which messed up equations in differential drive
  Implemented: Out of bounds detector implemented, which will serve as a condition for robots to be punished for 30 seconds
  Fix: fixed zero line crossing across the whole model (most of them should be ignored), which increases performance by around x4. This also fixed the error of our model hanging at 19.3 seconds when using the auto solver. The "Workaround" of using solver ode23 is no longer necessary
  Improvement: Optimized solver parameters for best possible performance and accuracy

# Sun. 13.05
- Daniel:
  Implemented: Out of bounds detection for all robots is now implemented, which sends a pulse to the OFF_Cond lane. This signal is held for 30seconds inside our robot and after these 30seconds the roboter is allowed to drive in bounds again (no time restriction) and as soon as he was inbounds for at least 1 step, he is supseptible to punishment again whenever he leaves the playzone.
  Fix: Enhancements of proximity sensor performance by x20-40, mainly by disabling zero line crossing detection in places where it was not necessary.
  Fix: Radial to degree conversion performance enhancement and using new theta threashholds for turning conditions - which significantly speeds up the tactic progress
  Implemented: Own collector will now never drive out of bounds himself, even if opponent is sensed in front of him. He will only drive until the opponent was pushed out of bounds, and then continue with the other parts of the tactic.
  Fix: Removal/Fix of 60 warnings which occumulated over the last 3 days.
  Fix: Algebraic loop between CollectorB, ScoutB and God removed, this also applies to input of differential drive
  Implemented: Tactic improvement, scout now sends the coordinate of the sensor which sensed the highest value instead of sending the scouts center position whenever sensing a value on ONE of the sensors
  Implemented: 0.5% chance to loose communication
  Implemented: Scout upadtes collector with his position every 1s
  Implemented: Parameters interchangable (gamesize x,y, different noise strengths, gridsize)

   
  TODO: Collector does not push our scout
  TODO: Collision
  TODO: 3 Models to demonstrate functions as mentioned on sheet